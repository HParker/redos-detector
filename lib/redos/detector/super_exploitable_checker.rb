module Redos
  module Detector
    class SuperExploitableChecker
      class Path
        attr_reader :path
        
        def initialize(path = [])
          @path = path
        end

        def append(transition)
          Path.new(path + [transition])
        end

        def last_state
          @path.last.to
        end

        def states
          @path.map { |t|
            [t.from, t.to]
          }.flatten
        end
        
        def draw
          @path.each do |t|
            if t.char == "epsilon"
              print "#{t.from.id} -- Îµ --> #{t.to.id}, "
            else
              print "#{t.from.id} -- #{t.char} --> #{t.to.id}, "
            end
          end
          puts
        end
      end
      
      def initialize(string)
        @string = string
        @nfa = Redos::Detector::NFA.from_string(string).first
      end

      def check
        @nfa.states.map { |state|
          loop_back_paths(state)
        }.flatten
      end

      private

      def loop_back_paths(state)
        loops = []
        paths = []

        # get some start states populated
        @nfa.transitions.each do |t|
          if t.from.id == state.id
            paths << Path.new([t])
          end
        end

        return paths if paths.empty?

        # TODO: I think if we do better loop detection we don't need this 100.times
        10.times do
          new_paths = []
          
          paths.each do |p|
            if p.last_state.id == state.id
              loops << p
              next
            end

            @nfa.transitions.each do |t|
              if p.last_state.id == t.from.id # && loops.none? { |l| l.path.any? { |pt| pt === t } }
                
                new_paths << p.append(t)
              end
            end
          end
          paths = new_paths
        end
        
        loops
      end

      #recursive path traversal to reach 
      def path_to_state(start, finish)
        paths = []
        
      end
    end
  end
end
